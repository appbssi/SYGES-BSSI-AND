/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a strict role-based and ownership-based access control model for a military agent and mission management system.
 *
 * Data Structure:
 * - /agents/{agentId}: Stores agent information. Only admins can create, modify, or delete agents. Any authenticated user can list agents.
 * - /missions/{missionId}: Stores mission information. Only admins can create, modify, or delete missions. Any authenticated user can list missions.
 * - /agents/{agentId}/missions/{missionId}: Represents the assignment of an agent to a specific mission. Access is controlled by the agentId and missionId.
 *
 * Key Security Decisions:
 * - Agents and missions can be listed by any authenticated user, but only administrators can create, update, or delete them.  Since the authentication system only provides "password" and "anonymous", there are no roles. Thus, all create, update and delete permissions are denied.
 * - AgentMission documents are nested under the /agents/{agentId} path to ensure that access to mission assignments is restricted to authorized personnel.
 * - The ruleset leans towards a secure-by-default posture, explicitly denying access where authorization is unclear.
 *
 * Denormalization for Authorization:
 * - AgentMission documents are nested under the agent to simplify authorization. The agentId and missionId are used in the path to establish ownership.
 *
 * Structural Segregation:
 * - Publicly listable data (agents and missions) is separated from private user data (AgentMissions) to avoid overly permissive list operations.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to the /agents collection.
     * @path /agents/{agentId}
     * @allow get, list: Any authenticated user can read agent data.
     * @allow create, update, delete: No user can modify agent data.
     * @deny create, update, delete: All users are denied write access.
     * @principle Read access is public, write access is restricted.
     */
    match /agents/{agentId} {
      allow get, list: if isSignedIn();
      allow create, update, delete: if false;
    }

    /**
     * @description Controls access to the /missions collection.
     * @path /missions/{missionId}
     * @allow get, list: Any authenticated user can read mission data.
     * @allow create, update, delete: No user can modify mission data.
     * @deny create, update, delete: All users are denied write access.
     * @principle Read access is public, write access is restricted.
     */
    match /missions/{missionId} {
      allow get, list: if isSignedIn();
      allow create, update, delete: if false;
    }

    /**
     * @description Controls access to the /agents/{agentId}/missions/{missionId} subcollection.
     * @path /agents/{agentId}/missions/{missionId}
     * @allow get: Any authenticated user can read an AgentMission.
     * @allow list: The agent (or an admin) can list missions for the agent.
     * @allow create: An agent can be assigned to a mission if the agentId in the path matches the agentId in the request.
     * @allow update: Only the agent can update their mission assignments.
     * @allow delete: Only the agent can delete their mission assignments.
     * @deny create: If the agentId in the path does not match the agentId in the request.
     * @deny update, delete: If the document does not exist.
     * @principle Enforces ownership for mission assignments and validates data integrity.
     */
    match /agents/{agentId}/missions/{missionId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn() && isOwner(agentId);
      allow create: if isSignedIn() && request.resource.data.agentId == agentId;
      allow update: if isSignedIn() && isExistingOwner(agentId);
      allow delete: if isSignedIn() && isExistingOwner(agentId);
    }
  }

  // Helper functions
  function isSignedIn() {
    return request.auth != null;
  }

  function isOwner(userId) {
    return request.auth.uid == userId;
  }

  function isExistingOwner(userId) {
    return isOwner(userId) && resource != null;
  }
}